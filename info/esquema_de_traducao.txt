INÍCIO-> 	{DECL_A | COMANDO} eof

DECL_A-> 	(int | float | string | char) DECL_B {,DECL_B} ;	|
			const id (u) = [- (z0)] valor (z1) (z2) (z3);

DECL_B-> 		id [<- [- (z0)] valor (z1) (z4) (z5) ]

COMANDO->	id (2) (14) ["[" (15) EXP_A1 (4) "]"] <- EXP_A2 (16);		  |
			while EXP_A (17) TIPO_CMD				        |
			if EXP_A (17) TIPO_CMD [else TIPO_CMD]			|
			readln "(" id (2) ")";				            |
			(write | writeln) "(" LISTA_EXP ")";		|
			;

TIPO_CMD->	COMANDO | "{" {COMANDO}+ "}"
LISTA_EXP->	EXP_A {, EXP_A}
OPERADOR->    	= (y)| != (z) | < (z)| > (z)| <= (z)| >= (z)

EXP_A-> 	EXP_B1 (x3) [(x) OPERADOR EXP_B2 (x1) (x2)]
EXP_B->		[-] EXP_C { (+ | - | "||") EXP_C }
EXP_C->		EXP_D { ("*" | && | / | div | mod) EXP_D }
EXP_D->		{! (11) } EXP_E (12) (13)
EXP_E->		(int (9) | float (10) ) "(" EXP_A (8) ")" | EXP_F (7)
EXP_F->     "(" EXP_A1 ")" (6)  | id (2)(3) ["[" EXP_A2 (4)(5) "]"] | valor (1)

XXX (1): {EXP_F.tipo := valor.tipo}
XXX (2): {if id.simbolo.classe = null then ERRO}
XXX (3): {EXP_F.tipo := id.simbolo.tipo}
XXX (4): {if (EXP_A2.tipo != integer | id.simbolo.tipo != string) then ERRO}
XXX (5): {EXP_F.tipo := char}
XXX (6): {EXP_F.tipo := EXP_A1.tipo}
XXX (7): {EXP_E.tipo := EXP_F.tipo}
XXX (8): {if !(EXP_A.tipo = integer | EXP_A.tipo = float) then ERRO}
XXX (9): {EXP_E.tipo := integer}
XXX (10): {EXP_E.tipo := float}
XXX (11): {houve_negacao = True}
XXX (12): {if (houve_negacao & EXP_E.tipo != bool) then ERRO}
XXX (13): {EXP_D.tipo := EXP_E.tipo}
XXX (14): {if id.simbolo.classe != "var" then ERRO}
XXX (15): {isStringIndex = true}
XXX (16): {if ((isStringIndex & EXP_A2.tipo != char) || (!isStringIndex & EXP_A2.tipo != id.simbolo.tipo)) then ERRO}
XXX (17): {if EXP_A.tipo != bool then ERRO}

Regras fora de ordem:
XXX (x): {OPERADOR.tipo := EXP_B1.tipo}
XXX (y): {if OPERADOR.tipo != (string|int|float|char) then ERRO}
XXX (z): {if OPERADOR.tipo != (int|float|char) then ERRO}
XXX (x1): {if !((EXP_B1.tipo = string & EXP_B2.tipo = string) | 
		(EXP_B1.tipo = integer & EXP_B2.tipo = integer) |
		(EXP_B1.tipo = float & EXP_B2.tipo = integer) |
		(EXP_B1.tipo = integer & EXP_B2.tipo = float) |
		(EXP_B1.tipo = float & EXP_B2.tipo = float)) then ERRO}
XXX (x2): {EXP_A.tipo := bool} 
XXX (x3): {EXP_A.tipo := EXP_B1.tipo} 
XXX (z0): {minus = True}
XXX (z1): {if (minus & !(valor.tipo = integer | valor.tipo = float)) then ERRO}
XXX (z2): {id.simbolo.tipo := valor.tipo_constante}
XXX (z3): {id.simbolo.classe := constante}
XXX (z4): {id.simbolo.tipo := valor.tipo_variavel}
XXX (z5): {id.simbolo.classe := variavel}
XXX (u): {if id.simbolo.classe != null then ERRO_id_declarado}


// Duvidas:
1. Implementação da regra (x2)
2. Pode repetir (z0) e (z1) para variavel? Em DECL_B e EXP_C
3. tipo_constante?
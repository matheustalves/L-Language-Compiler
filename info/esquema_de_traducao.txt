INÍCIO-> 	{DECL_A | COMANDO} eof

DECL_A-> 	(int | float | string | char) DECL_B {,DECL_B} ;	|
			const id (u) = [- (z0)] valor (z1) (z2) (z3);

DECL_B-> 		id [<- [-] valor ]

//TIPO_DECL-> 	[-]num | string | hexa | caractere
//não pode ter token diferente para cada tipo de declaração: token constante e token valor, analisador léxico difere pelo formato

COMANDO->	id ["[" EXP_A "]"] <- EXP_A;		    	|
			while EXP_A TIPO_CMD				        |
			if EXP_A TIPO_CMD [else TIPO_CMD]			|
			readln "(" id ")";				            |
			(write | writeln) "(" LISTA_EXP ")";		|
			;

TIPO_CMD->	COMANDO | "{" {COMANDO}+ "}"
LISTA_EXP->	EXP_A {, EXP_A}
OPERADOR->    	= (y)| != (z) | < (z)| > (z)| <= (z)| >= (z)

EXP_A-> 	EXP_B1 (x3) [(x) OPERADOR EXP_B2 (x1) (x2)]
EXP_B->		[-] EXP_C { (+ | - | "||") EXP_C }
EXP_C->		EXP_D { ("*" | && | / | div | mod) EXP_D }
EXP_D->		{! (11) } EXP_E (12) (13)
EXP_E->		(int (9) | float (10) ) "(" EXP_A (8) ")" | EXP_F (7)
EXP_F->     "(" EXP_A1 ")" (6)  | id (2)(3) ["[" EXP_A2 (4)(5) "]"] | valor (1)

(1): {EXP_F.tipo := valor.tipo_constante}
(2): {if id.simbolo.classe = null then ERRO}
(3): {EXP_F.tipo := id.simbolo.tipo}
(4): {if (EXP_A2.tipo != integer | id.simbolo.tipo != string) then ERRO}
(5): {EXP_F.tipo := char}
(6): {EXP_F.tipo := EXP_A1.tipo}
(7): {EXP_E.tipo := EXP_F.tipo}
(8): {if !(EXP_A.tipo = integer | EXP_A.tipo = float) then ERRO}
(9): {EXP_E.tipo := integer}
(10): {EXP_E.tipo := float}
(11): {houve_negacao = True}
(12): {if (houve_negacao & EXP_E.tipo != bool) then ERRO}
(13): {EXP_D.tipo := EXP_E.tipo}


Regras fora de ordem:
(x): {OPERADOR.tipo := EXP_B1.tipo}
(y): {if OPERADOR.tipo != (string|int|float) then ERRO}
(z): {if OPERADOR.tipo != (int|float) then ERRO}
(x1): {if !((EXP_B1.tipo = string & EXP_B2.tipo = string) | 
		(EXP_B1.tipo = integer & EXP_B2.tipo = integer) |
		(EXP_B1.tipo = float & EXP_B2.tipo = integer) |
		(EXP_B1.tipo = integer & EXP_B2.tipo = float) |
		(EXP_B1.tipo = float & EXP_B2.tipo = float)) then ERRO}
//lei de deMorgan !(A&B) = (!A|!B) e !(A|B) = (!A&!B)
(x2): {EXP_A.tipo := bool} 
(x3): {EXP_A.tipo := EXP_B1.tipo} 
(z0): {minus = True}
(z1): {if !(minus & (valor.tipo = integer | valor.tipo = float)) then ERRO}
(z2): {id.simbolo.tipo := valor.tipo_constante}
(z3): {id.simbolo.classe := constante}
(u): {if id.simbolo.classe != null then ERRO_id_declarado}
